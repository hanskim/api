package api.lang.thread;

/* 프로그램 : 특정 기능을 목표로 이뤄진 함수,  프로제셔 , 메소드 집합
 * Process : 구동(실행) 중인 프로그램 ( 자바 F11을 누른 순간)   // 프로세스 = task = 작업
 * Thread의 집합으로 하나의 exe , com, dll  같은 프로그램을 포함
 * Process간 자원(memory = resource) 를 공유할 수 없다
 * 따라서 Process 를 많이 발생시키면 자원 낭비
 * 
 * Thread
 * 반복적으로 동기화하여 실행되는 프로그램의 루틴(루틴  ≒  함수)
 * 메소드 단위의 처리모듈,  Process의 구성요소
 * 
 * Thread 는 많이 발생해도 자원을 공유( => 하는 건 인스턴스와 static이고 이걸 공유하는 건 메소드) 
 * ( ※  (싱글) Thread는 F11이 실행된 메소드다) 
 * 
 * 함으로써 (이  Process 에 대해 시스템에 부담이 적음)
 * 
 * - 구현방법
 * 1. Thread 클래스 상속
 * 2. Runnable 인터페이스를 구현   => 객체지향이 더 맞음!!
 * 
 * Thread CallBack 메소드
 * start() : JVM  이 스케쥴 상 여유가 생겼을 때 쓰레드 스케쥴 상 run()이 호출된다
 * run() : 스레드상태에서 처리하고자 하는 모든 비즈니스 로직이 구현됨
 * sleep(long second) : 지정한 시간동안 스레드를 쉬게 하고, 그 시간이 지나면 다시 작동 1/1000 초
 * wait() : 현재 스페드 무한대기 , notify() , notifyAll() , 메소드를 재실행시킴
 * suspend() : 일시정지, 재실행은 resume() 
 * yield () : 스레드 실행권한을 다른 스레드에게 넘김
 * stop () : 스레드 실행을 종료
 * 
 * 
 * 단일 스레드
 * 하나의 자바 프로그램 실행 상태
 * main() 이 대표적인 싱글 스래드
 * 멀티스레드
 * 하나의 메소드가 실행하는 상태가 아닌 여러개의 메소드가 지속적으로 자원 공유상태에서 실행하는 것
 * 
 * 콜백
 * 메소드를 일정 실행순서로 대리 등록시켜놓고 
 * 등록된 순서에 따라 자동적으로 호출하는 메소드
 * 
 * 교착상태(Dead lock)
 * 두 스레드가 lock을 건 상태에서 서로  lock이 풀리기를 기다리는 상황으로
 * 프로그래머는 변수와 while문 if문 을 사용해서 스레드를 제어해야함
 * 
 * 
 * 
 * 
 * 
 */

public class ThreadSyntax {

}
